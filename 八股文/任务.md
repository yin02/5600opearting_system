# day10

## 进程和线程的区别
```
进程是资源分配和调度的基本单位。

线程是程序执行的最小单位，线程是进程的子任务，是进程内的执行单元。 一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存。

资源开销：

进程：由于每个进程都有独立的内存空间，创建和销毁进程的开销较大。进程间切换需要保存和恢复整个进程的状态，因此上下文切换的开销较高。
线程：线程共享相同的内存空间，创建和销毁线程的开销较小。线程间切换只需要保存和恢复少量的线程上下文，因此上下文切换的开销较小。
通信与同步：

进程：由于进程间相互隔离，进程之间的通信需要使用一些特殊机制，如管道、消息队列、共享内存等。
线程：由于线程共享相同的内存空间，它们之间可以直接访问共享数据，线程间通信更加方便。
安全性：

进程：由于进程间相互隔离，一个进程的崩溃不会直接影响其他进程的稳定性。
线程：由于线程共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。

掌握程度：
- 理解进程和线程在资源拥有、执行、上下文切换、创建和销毁开销方面的差异，能够清晰地描述进程和线程的定义、区别和联系。
- 知道进程间通信和线程间通信的不同方式及其特点。
- 如果有实际的多线程或多进程编程经验，能够结合实例讨论进程和线程的使用和最佳实践。
```

参考资料：
- 【操作系统】进程和线程的区别
- 进程和线程的比较

## 并行和并发有什么区别

掌握程度：
- 能够清晰地描述并发和并行的定义、区别和联系。
- 理解并发和并行在实现、性能、应用场景和复杂性方面的差异。

参考资料：
- 【一个视频告诉你“并发、并行、异步、同步”的区别】
```

并行是在同一时刻执行多个任务。
并发是在相同的时间段内执行多个任务，任务可能交替执行，通过调度实现。
并行是指在同一时刻执行多个任务，这些任务可以同时进行，每个任务都在不同的处理单元（如多个CPU核心）上执行。在并行系统中，多个处理单元可以同时处理独立的子任务，从而加速整体任务的完成。

并发是指在相同的时间段内执行多个任务，这些任务可能不是同时发生的，而是交替执行，通过时间片轮转或者事件驱动的方式。并发通常与任务之间的交替执行和任务调度有关。
```



## 解释一下用户态和核心态
```
用户态和内核态的区别
用户态和内核态是操作系统为了保护系统资源和实现权限控制而设计的两种不同的CPU运行级别，可以控制进程或程序对计算机硬件资源的访问权限和操作范围。

用户态：在用户态下，进程或程序只能访问受限的资源和执行受限的指令集，不能直接访问操作系统的核心部分，也不能直接访问硬件资源。
核心态：核心态是操作系统的特权级别，允许进程或程序执行特权指令和访问操作系统的核心部分。在核心态下，进程可以直接访问硬件资源，执行系统调用，管理内存、文件系统等操作。
在什么场景下，会发生内核态和用户态的切换
系统调用：当用户程序需要请求操作系统提供的服务时，会通过系统调用进入内核态。
异常：当程序执行过程中出现错误或异常情况时，CPU会自动切换到内核态，以便操作系统能够处理这些异常。
中断：外部设备（如键盘、鼠标、磁盘等）产生的中断信号会使CPU从用户态切换到内核态。操作系统会处理这些中断，执行相应的中断处理程序，然后再将CPU切换回用户态。

```
掌握程度：
● 能够清晰地描述用户态和核心态的定义、区别和它们在操作系统中的角色。
● 理解用户态和核心态在特权级别、系统调用、安全性和性能方面的差异。




这些内容涵盖了操作系统和并发编程中的重要概念，通常是技术面试中的高频考点。以下是你在这些话题上需要掌握的要点和一些相关建议。

### Day 11: 进程调度、通信、同步与互斥

#### 1. **进程调度算法**
- **常见调度算法**：
  - 先来先服务 (FCFS)
  - 短作业优先 (SJF)
  - 优先级调度
  - 时间片轮转 (Round Robin)
  - 多级反馈队列调度
- **应用场景**：
  - 实时系统可能使用优先级调度，而交互式系统可能更适合使用时间片轮转。

#### 2. **进程间通信方式（IPC）**
- **常见方式**：
  - 管道（Pipe）
  - 消息队列（Message Queue）
  - 共享内存（Shared Memory）
  - 信号量（Semaphore）
  - 套接字（Socket）
- **安全问题**：可能出现竞态条件，死锁等。需要使用同步机制来确保资源访问的安全。

#### 3. **进程同步与互斥**
- **互斥锁 (Mutex)**：保护共享资源，防止多个进程同时修改。
- **信号量 (Semaphore)**：控制多个进程对资源的访问。
- **条件变量 (Condition Variable)**：用于实现复杂的进程同步。

### Day 12: 死锁与锁机制

#### 1. **死锁与预防策略**
- **死锁的四个必要条件**：互斥、占有且等待、不剥夺、环路等待。
- **预防策略**：破坏上述条件之一，例如银行家算法。
- **死锁检测与恢复**：通过循环等待检测图来发现死锁，恢复机制通常是回滚或杀死进程。

#### 2. **常见锁机制**
- **乐观锁与悲观锁**：悲观锁假设竞争严重，每次访问资源时都会上锁；乐观锁假设竞争少，仅在提交数据时检测冲突。
- **自旋锁**：适用于锁持有时间短的场景，通过不停轮询的方式等待锁释放。

### Day 13: 线程同步与页面置换算法

#### 1. **线程同步机制**
- **常见方式**：
  - 互斥锁 (Mutex)
  - 自旋锁 (Spinlock)
  - 读写锁 (Read-Write Lock)
  - 条件变量 (Condition Variable)
  - 信号量 (Semaphore)
- **优缺点**：如自旋锁适合短时间锁，条件变量适用于更复杂的同步场景。

#### 2. **页面置换算法**
- **常见算法**：
  - 最优算法（OPT）
  - 先进先出（FIFO）
  - 最近最少使用（LRU）
  - 时钟算法（Clock）
  
### Day 15: Linux 命令与网络编程

#### 1. **常用 Linux 命令**
- **文件操作**：`ls`, `cp`, `mv`, `rm`
- **文件内容查看**：`cat`, `less`, `more`, `tail`, `head`
- **权限管理**：`chmod`, `chown`, `umask`
- **进程管理**：`ps`, `top`, `kill`
- **网络管理**：`netstat`, `ss`, `lsof`
- **端口检查**：`netstat -tuln`, `lsof -i :port`

#### 2. **select、poll 和 epoll**
- **select**：适用于较小的文件描述符集合，有最大文件描述符限制。
- **poll**：类似 `select`，但没有文件描述符数量限制。
- **epoll**：适用于大量文件描述符的场景，性能更高，使用事件驱动模型。

### 总结
这些知识点涵盖了进程与线程调度、进程间通信、同步与互斥、死锁预防以及页面置换等方面。你可以参考这些要点，结合实际案例与场景深入理解各个概念的应用。对于面试中的问答，确保不仅能够清晰描述，还要能够讨论不同算法、同步机制或锁机制的优缺点，并结合实际场景选择合适的方案。